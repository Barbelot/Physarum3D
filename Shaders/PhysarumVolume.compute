#define NUM_THREADS_1D 512
#define NUM_THREADS_3D 8

#pragma kernel InitParticles
#pragma kernel UpdateParticles
#pragma kernel InitTrail
#pragma kernel UpdateTrail
#pragma kernel BlurTrailX
#pragma kernel BlurTrailY
#pragma kernel BlurTrailZ
#pragma kernel DecayTrail
#pragma kernel UpdateParticleMap

#include "Random.cginc"

#define PI 3.14159265359
#define TWOPI 6.28318530718


struct Particle
{
	float3 position; 	
	float2 angle;
	float4 color;
	float3 velocity;
	float size;
};

float _AbsoluteTime;
float3 _Size;
float2 _SensorAngle;
float2 _RotationAngle;
float _SensorOffsetDistance; 
float _StepSize;
float _TrailDecay;
bool _DiffuseTrail;
float _TrailDiffuseSpeed;
float _TrailRepulsion;
float _RandomRotationProbability;
float3 _DebugVector;
float _TrailToSizeImportance;

RWStructuredBuffer<Particle> _ParticleBuffer;
RWTexture3D<float4> _TrailDensityWrite;
Texture3D<float4> _TrailDensityRead;

RWTexture2D<float4> _ParticlePositionMap;
RWTexture2D<float4> _ParticleColorMap;
RWTexture2D<float4> _ParticleVelocityMap;

SamplerState linearClampSampler;

float2 _ParticlePositionMapSize;

//RWTexture3D<half4> _MeshVoxels;
//float _MeshImportance;
//int _MeshSDFResolution;

/******************
FUNCTIONS
******************/

//Return 1 if v inside the sphere, 0 otherwise
float InsideSphere(float3 v, float3 center, float radius)
{
	float3 position = v - center;
	return (step(radius, length(position)) + 1.0) % 2.0;
}

float4 SampleDensityFromPosition(float3 pos) {

	return _TrailDensityRead.SampleLevel(linearClampSampler, pos, 0);
}

void WriteDensityFromPosition(float3 pos, float4 value) {

	_TrailDensityWrite[uint3(pos * _Size - float3(0.5, 0.5, 0.5))] = value;
}

/******************
KERNELS
******************/

[numthreads(NUM_THREADS_1D,1,1)]
void InitParticles(uint3 id: SV_DISPATCHTHREADID)
{

	//Initialize position
	//float x = Random(id.x * 48856) * _Size.x * 0.5f + _Size.x * 0.25f;
	//float y = Random(id.x * 12377) * _Size.y * 0.5f + _Size.y * 0.25f;
	//float z = Random(id.x * 67563) * _Size.z * 0.5f + _Size.z * 0.25f;

	//float3 pos = float3(x, y, z);
	float3 pos = RandomPointInSphere(id.x) * _Size * 0.05f + _Size * 0.5f;

	float4 color = float4(1, 1, 1, 1);

	//float2 rotationToCenter = DirectTo(pos, _Size * 0.5f);
	float2 randomRotation = float2(Random(id.x) * TWOPI, Random(id.x + 1) * TWOPI);

	_ParticleBuffer[id.x].position = pos;
	_ParticleBuffer[id.x].color = color;
	_ParticleBuffer[id.x].angle = randomRotation;
	_ParticleBuffer[id.x].size = 1.0f;
}

[numthreads(NUM_THREADS_1D,1,1)]
void UpdateParticles (uint3 id: SV_DISPATCHTHREADID)
{
	
	float3 pos = _ParticleBuffer[id.x].position;
	float4 color = _ParticleBuffer[id.x].color;
	float2 angle = _ParticleBuffer[id.x].angle;

	float trailValue = 0;

	//Read trail
	float leftAngle = angle.x + _SensorAngle.x;
	float rightAngle = angle.x - _SensorAngle.x;
	float topAngle = angle.y + _SensorAngle.y;
	float downAngle = angle.y - _SensorAngle.y;

	//3D
	float3 frontPos =		pos + float3(cos(angle.y) * cos(angle.x), sin(angle.y) * cos(angle.x), sin(angle.x)) * _SensorOffsetDistance;
	float3 frontLeftPos =	pos + float3(cos(angle.y) * cos(leftAngle), sin(angle.y) * cos(leftAngle), sin(leftAngle)) * _SensorOffsetDistance;
	float3 frontRightPos =	pos + float3(cos(angle.y) * cos(rightAngle), sin(angle.y) * cos(rightAngle), sin(rightAngle)) * _SensorOffsetDistance;
	float3 frontTop =		pos + float3(cos(topAngle) * cos(angle.x), sin(topAngle) * cos(angle.x), sin(angle.x)) * _SensorOffsetDistance;
	float3 frontDown =		pos + float3(cos(downAngle) * cos(angle.x), sin(downAngle) * cos(angle.x), sin(angle.x)) * _SensorOffsetDistance;
	//float3 frontTopLeftPos = pos + float3(cos(topAngle) * cos(leftAngle), sin(topAngle) * cos(leftAngle), sin(leftAngle)) * _SensorOffsetDistance;
	//float3 frontTopRightPos = pos + float3(cos(topAngle) * cos(rightAngle), sin(topAngle) * cos(rightAngle), sin(rightAngle)) * _SensorOffsetDistance;
	//float3 frontDownLeftPos = pos + float3(cos(downAngle) * cos(leftAngle), sin(downAngle) * cos(leftAngle), sin(leftAngle)) * _SensorOffsetDistance;
	//float3 frontDownRight = pos + float3(cos(downAngle) * cos(rightAngle), sin(downAngle) * cos(rightAngle), sin(rightAngle)) * _SensorOffsetDistance;

	float F = SampleDensityFromPosition(frontPos).w;
	float FL = SampleDensityFromPosition(frontLeftPos).w;
	float FR = SampleDensityFromPosition(frontRightPos).w;
	float FT = SampleDensityFromPosition(frontTop).w;
	float FD = SampleDensityFromPosition(frontDown).w;
	//float FTL = SampleDensityFromPosition(frontTopLeftPos).w;
	//float FTR = SampleDensityFromPosition(frontTopRightPos).w;
	//float FDL = SampleDensityFromPosition(frontDownLeftPos).w;
	//float FDR = SampleDensityFromPosition(frontDownRight).w;

	//Get new position
	if (Random(id.x * 456 + _AbsoluteTime) < _RandomRotationProbability) {
		//RandomRotation
		angle.x += _RotationAngle.x * RandomSign(id.x + _AbsoluteTime);
		angle.y += _RotationAngle.y * RandomSign(id.x + 254 + _AbsoluteTime);
	}
	else {

		int maxIndex = 0;
		float maxValue = F;
		float trailThreshold = 1. - _TrailRepulsion;

		if (FL > maxValue && FL < trailThreshold) { maxIndex = 1; maxValue = FL; }
		if (FR > maxValue && FR < trailThreshold) { maxIndex = 2; maxValue = FR; }
		if (FT > maxValue && FT < trailThreshold) { maxIndex = 3; maxValue = FT; }
		if (FD > maxValue && FD < trailThreshold) { maxIndex = 4; maxValue = FD; }
		//if (FTL > maxValue && FTL < trailThreshold) { maxIndex = 5; maxValue = FTL; }
		//if (FTR > maxValue && FTR < trailThreshold) { maxIndex = 6; maxValue = FTR; }
		//if (FDL > maxValue && FDL < trailThreshold) { maxIndex = 7; maxValue = FDL; }
		//if (FDR > maxValue && FDR < trailThreshold) { maxIndex = 8; maxValue = FDR; }

		if (maxIndex == 0 && F >= trailThreshold) {
			angle.x += _RotationAngle.x * RandomSign(id.x + _AbsoluteTime);
			angle.y += _RotationAngle.y * RandomSign(id.x + 254 + _AbsoluteTime);
		}
		if (maxIndex == 1) { angle.x += _RotationAngle.x; }
		if (maxIndex == 2) { angle.x -= _RotationAngle.x; }
		if (maxIndex == 3) { angle.y += _RotationAngle.y; }
		if (maxIndex == 4) { angle.y -= _RotationAngle.y; }
		//if (maxIndex == 5) { angle.x += _RotationAngle.x; angle.y += _RotationAngle.y; }
		//if (maxIndex == 6) { angle.x -= _RotationAngle.x; angle.y += _RotationAngle.y; }
		//if (maxIndex == 7) { angle.x += _RotationAngle.x; angle.y -= _RotationAngle.y; }
		//if (maxIndex == 8) { angle.x -= _RotationAngle.x; angle.y -= _RotationAngle.y; }

		trailValue = maxValue;
	}

	float3 newPos = pos + float3(cos(angle.y) * cos(angle.x), sin(angle.y) * cos(angle.x), sin(angle.x)) * _StepSize;

	//Check boundaries

	//3D Cube
	//if (newPos.x > _Size.x - 1) { newPos.x = 0; }
	//if (newPos.y > _Size.y - 1) { newPos.y = 0; }
	//if (newPos.z > _Size.z - 1) { newPos.z = 0; }
	//if (newPos.x < 0) { newPos.x = _Size.x - 1; }
	//if (newPos.y < 0) { newPos.y = _Size.y - 1; }
	//if (newPos.z < 0) { newPos.z = _Size.z - 1; }

	//3D Sphere
	float inside = InsideSphere(newPos, _Size * 0.5f, _Size.x * 0.5f);
	//RandomRotation
	angle.x += (_RotationAngle.x * RandomSign(id.x + _AbsoluteTime)) * (1 - inside);
	angle.y += (_RotationAngle.y * RandomSign(id.x + 254 + _AbsoluteTime)) * (1 - inside);

	newPos = newPos * inside + pos * (1 - inside);

	//Move particule
	_ParticleBuffer[id.x].velocity = newPos - pos;
	_ParticleBuffer[id.x].position = newPos;
	_ParticleBuffer[id.x].angle = angle;
	_ParticleBuffer[id.x].color = color;
	_ParticleBuffer[id.x].size = trailValue * _TrailToSizeImportance;

	//Update trail
	WriteDensityFromPosition(newPos, min(SampleDensityFromPosition(newPos) + _ParticleBuffer[id.x].color, 1));
}

[numthreads(NUM_THREADS_3D, NUM_THREADS_3D, NUM_THREADS_3D)]
void InitTrail(uint3 id : SV_DISPATCHTHREADID)
{
	_TrailDensityWrite[id] = float4(0,0,0,0);
}

[numthreads(NUM_THREADS_3D, NUM_THREADS_3D, NUM_THREADS_3D)]
void UpdateTrail (uint3 id : SV_DISPATCHTHREADID)
{
	float3 uv = (id + float3(0.5, 0.5, 0.5)) / _Size;
	float4 value = _TrailDensityRead.SampleLevel(linearClampSampler, uv, 0);

	float3 duv = 1.0 / _Size;

	//Mean filter

	if (_DiffuseTrail) {

		//3D
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv - duv, 0) * _TrailDiffuseSpeed; // -1,-1,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x, -duv.y,		0), 0) * _TrailDiffuseSpeed; // -1,-1, 0
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x, -duv.y,  duv.z), 0) * _TrailDiffuseSpeed; // -1,-1,+1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x,      0, -duv.z), 0) * _TrailDiffuseSpeed; // -1, 0,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x,		0,		0), 0) * _TrailDiffuseSpeed; // -1, 0, 0
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x,		0,  duv.z), 0) * _TrailDiffuseSpeed; // -1, 0,+1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x,  duv.y, -duv.z), 0) * _TrailDiffuseSpeed; // -1,+1,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x,  duv.y,		0), 0) * _TrailDiffuseSpeed; // -1,+1, 0
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x,  duv.y,  duv.z), 0) * _TrailDiffuseSpeed; // -1,+1,+1

		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0, -duv.y, -duv.z), 0) * _TrailDiffuseSpeed; //  0,-1,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0, -duv.y,	   0), 0) * _TrailDiffuseSpeed; //  0,-1, 0
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0, -duv.y,  duv.z), 0) * _TrailDiffuseSpeed; //  0,-1,+1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0,	   0, -duv.z), 0) * _TrailDiffuseSpeed; //  0, 0,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0,      0,  duv.z), 0) * _TrailDiffuseSpeed; //  0, 0,+1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0,  duv.y, -duv.z), 0) * _TrailDiffuseSpeed; //  0,+1,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0,  duv.y,      0), 0) * _TrailDiffuseSpeed; //  0,+1, 0
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0,  duv.y,  duv.z), 0) * _TrailDiffuseSpeed; //  0,+1,+1

		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x, -duv.y, -duv.z), 0) * _TrailDiffuseSpeed; // +1,-1,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x, -duv.y,      0), 0) * _TrailDiffuseSpeed; // +1,-1, 0
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x, -duv.y,  duv.z), 0) * _TrailDiffuseSpeed; // +1,-1,+1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x,      0, -duv.z), 0) * _TrailDiffuseSpeed; // +1, 0,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x,      0,      0), 0) * _TrailDiffuseSpeed; // +1, 0, 0
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x,      0,  duv.z), 0) * _TrailDiffuseSpeed; // +1, 0,+1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x,  duv.y, -duv.z), 0) * _TrailDiffuseSpeed; // +1,+1,-1
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x,  duv.y,      0), 0) * _TrailDiffuseSpeed; // +1,+1, 0
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + duv, 0) * _TrailDiffuseSpeed; // +1,+1,+1

		value = (value / (1. + 26.*_TrailDiffuseSpeed));
	}

	value *= 1.0f - _TrailDecay;

	//Add mesh sdf
	//float meshDist = _MeshVoxels[uint3(((float)id.x * (float)_MeshSDFResolution / (float)_Size.x),
	//	((float)id.y * (float)_MeshSDFResolution / (float)_Size.y),
	//	((float)id.z * (float)_MeshSDFResolution / (float)_Size.z))].x;

	//value.w = lerp(value.w, 1.0f - meshDist, _MeshImportance);

	_TrailDensityWrite[id] = value;

}

[numthreads(NUM_THREADS_3D, NUM_THREADS_3D, NUM_THREADS_3D)]
void BlurTrailX(uint3 id : SV_DISPATCHTHREADID)
{
	float3 uv = (id + float3(0.5, 0.5, 0.5)) / _Size;
	float4 value = _TrailDensityRead.SampleLevel(linearClampSampler, uv, 0);

	float3 duv = 1.0 / _Size;

	//Mean filter

	if (_DiffuseTrail) {

		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(-duv.x, 0, 0), 0) * _TrailDiffuseSpeed;
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(duv.x, 0, 0), 0) * _TrailDiffuseSpeed;

		value = (value / (1. + 2. * _TrailDiffuseSpeed));
	}

	_TrailDensityWrite[id] = value;

}

[numthreads(NUM_THREADS_3D, NUM_THREADS_3D, NUM_THREADS_3D)]
void BlurTrailY(uint3 id : SV_DISPATCHTHREADID)
{
	float3 uv = (id + float3(0.5, 0.5, 0.5)) / _Size;
	float4 value = _TrailDensityRead.SampleLevel(linearClampSampler, uv, 0);

	float3 duv = 1.0 / _Size;

	//Mean filter

	if (_DiffuseTrail) {

		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0, duv.y, 0), 0) * _TrailDiffuseSpeed;
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0, -duv.y, 0), 0) * _TrailDiffuseSpeed;

		value = (value / (1. + 2. * _TrailDiffuseSpeed));
	}

	_TrailDensityWrite[id] = value;

}

[numthreads(NUM_THREADS_3D, NUM_THREADS_3D, NUM_THREADS_3D)]
void BlurTrailZ(uint3 id : SV_DISPATCHTHREADID)
{
	float3 uv = (id + float3(0.5, 0.5, 0.5)) / _Size;
	float4 value = _TrailDensityRead.SampleLevel(linearClampSampler, uv, 0);

	float3 duv = 1.0 / _Size;

	//Mean filter

	if (_DiffuseTrail) {

		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0, 0, duv.z), 0) * _TrailDiffuseSpeed;
		value += _TrailDensityRead.SampleLevel(linearClampSampler, uv + float3(0, 0, -duv.z), 0) * _TrailDiffuseSpeed;

		value = (value / (1. + 2. * _TrailDiffuseSpeed));
	}

	_TrailDensityWrite[id] = value;

}

[numthreads(NUM_THREADS_3D, NUM_THREADS_3D, NUM_THREADS_3D)]
void DecayTrail(uint3 id : SV_DISPATCHTHREADID)
{
	float4 value = _TrailDensityRead[id];
	value *= 1.0f - _TrailDecay;
	_TrailDensityWrite[id] = value;
}

[numthreads(NUM_THREADS_1D, 1, 1)]
void UpdateParticleMap(uint3 id : SV_DISPATCHTHREADID)
{
	uint2 mapCoord = uint2(id.x % _ParticlePositionMapSize.x, id.x / _ParticlePositionMapSize.x);

	float3 particlePos = _ParticleBuffer[id.x].position;

	_ParticlePositionMap[mapCoord] = float4(particlePos.x / _Size.x, particlePos.y / _Size.y, particlePos.z / _Size.z, _ParticleBuffer[id.x].size);
	_ParticleColorMap[mapCoord] = _ParticleBuffer[id.x].color;
	_ParticleVelocityMap[mapCoord] = float4(_ParticleBuffer[id.x].velocity, 1);
}

